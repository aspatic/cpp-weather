// 子进程是父进程的副本
// 子进程获得了一份父进程的数据空间，队和栈的副本，不是同一个文件的共享
// 父进程中打开的文件描述符也复制了一份给子进程，可能会导致之前的缓冲内容被两个进程各写入一遍
// 如果父进程先退出，子进程会成为孤儿进程，会导致被1号进程收养
// 如果子进程先退出，内核会给父进程发送SIGCHLD信号，如果父进程没有处理这个信号，子进程就会变成僵尸进程

// 如果子进程在父进程终止之前终止，内核会为这个自进程保留一个数据结构，包括进程编号，终止状态和使用CPU的时间等
// 父进程如果处理了这个子进程的退出信息，内核就会彻底释放掉这个数据结构
// 如果父进程没有处理子进程的退出信息，内核就不会释放该数据结构，子进程的进程编号也会一直被占用直到父进程也退出
// 由于系统总共可用的内存和进程编号都是有限的，如果大量产生僵尸进程，会耗尽系统的资源导致不能产生新的进程
// 这就是僵尸的危害

int main(){
    int pid = fork();
    if (pid==0){
        printf("This is the child process #%d running.\n",getpid());
        sleep(5);
    }
    if (pid > 0){
        printf("This is the parent process #%d running.\n",getpid());
        sleep(10);
    }
    else{
        printf("fork error\n");
    }
}